{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"평소에 어떻게 메인페이지를 구성할까 생각하다 fullpage.js를 적용해보기로 했다.\nfullpage.js란 배달의민족와 같이 이미지 또는 동영상으로 스크롤하면 페이지 단위로 움직이는 제이쿼리 플러그인이다.\nFullpage 1. 설치하기 우선 fullpage.js는 v2.xx까지는 무료이지만 v3부터는 유료 라이센스키가 필요하기 때문에 우리는 v2.96…","fields":{"slug":"/fullpage사용하기/"},"frontmatter":{"date":"July 10, 2023","title":"fullpage.js 사용하기","tags":["ReactJS","TypeScript","Blog","fullpage"]},"rawMarkdownBody":"\r\n평소에 어떻게 메인페이지를 구성할까 생각하다 fullpage.js를 적용해보기로 했다.\r\nfullpage.js란 [배달의민족](https://www.baemin.com/?gclid=Cj0KCQjwtamlBhD3ARIsAARoaEy0xD47wHqxZVeHroSIN46fCLVhOgE5aFG9YnxBTtBxCDOj0GCvZskaAuYfEALw_wcB)와 같이 이미지 또는 동영상으로 스크롤하면 페이지 단위로 움직이는 제이쿼리 플러그인이다.\r\n[Fullpage](https://alvarotrigo.com/fullPage/ko/)\r\n\r\n## 1. 설치하기\r\n\r\n- 우선 fullpage.js는 v2.xx까지는 무료이지만 v3부터는 유료 라이센스키가 필요하기 때문에 우리는 v2.96으로 다운그레이드하여 사용할 것이다.\r\n\r\n> `npm i fullpage.js@2.9.6`\r\n>\r\n> `npm i jquery --save`\r\n>\r\n> `npm i @types/fullpage.js@2.9.3`\r\n\r\n로 fullpage와 jquery를 설치해준다.\r\n\r\n## 2. 페이지 적용하기\r\n\r\n### 2-1. 기촐 레이아웃 생성\r\n\r\n```Typescript\r\n\r\nimport $ from \"jquery\"; // jquery를 선언해준다.\r\nimport \"fullpage.js\";\r\nimport \"fullpage.js/dist/jquery.fullpage.min.css\";\r\n\r\nconst Home = () => {\r\n  $(() => {\r\n    $(\"#fullpage\").fullpage({\r\n      menu: \"#menu\",\r\n      anchors: [\"1\", \"2\", \"3\", \"4\"],\r\n      sectionsColor: [\"black\", \"blue\", \"red\", \"orange\"],\r\n    });\r\n  });\r\n\r\n  return (\r\n    <Layout>\r\n      <div id=\"fullpage\">\r\n        <div className=\"section\" id=\"#section1\">\r\n          1번\r\n        </div>\r\n        <div className=\"section\" id=\"#section2\">\r\n          2번\r\n        </div>\r\n        <div className=\"section\" id=\"#section3\">\r\n          3번\r\n        </div>\r\n        <div className=\"section\" id=\"#section4\">\r\n          4번\r\n        </div>\r\n      </div>\r\n    </Layout>\r\n  );\r\n};\r\n```\r\n\r\n> import \"fullpage.js\";\r\n>\r\n> import \"fullpage.js/dist/jquery.fullpage.min.css\";\r\n\r\n를 불러온후 jQuery를 사용하여 위와같이 설정해준다. 그 후 id로 섹션별로 구분해준다.\r\n\r\n### 2-2. 동영상 추가하기\r\n\r\n```Typescript\r\n@types/global/index.d.ts\r\n\r\ndeclare module \"*.png\";\r\ndeclare module \"*.jpg\";\r\n\r\ndeclare module \"*.mp4\";\r\n```\r\n\r\n타입스크립트에서는 모듈 확장을 사용하여 기존 모듈 또는 라이브러리의 기능을 확장할 수 있다. 우리는 동영상 파일을 사용해야하고, 컴파일러가 이러한 파일 형식을 만났을 때 오류를 발생시키는 것을 방지하기 위해 선언해준다.\r\n<br/>\r\n그 후에 비디오를 보여줄 컴포넌트를 생성해준다.\r\n\r\n```Typescript\r\nconst fullpageSection = () => {\r\n  const videos = [sea, grape, food];\r\n\r\n  return (\r\n    <>\r\n      {videos.map((video, index) => (\r\n        <div className=\"section\" id={`#section${index}`}>\r\n          <video\r\n            className=\"h-full w-full object-cover\"\r\n            data-autoplay\r\n            muted\r\n            loop\r\n          >\r\n            <source src={video} type=\"video/mp4\" />\r\n          </video>\r\n        </div>\r\n      ))}\r\n    </>\r\n  );\r\n};\r\n```\r\n\r\n그 후 다음과 같이 FullpageSection 컴포넌트를 불러와 수정해준다.\r\n\r\n```Typescript\r\n\r\nimport Layout from \"@components/Layout/layout\";\r\nimport $ from \"jquery\";\r\nimport \"fullpage.js\";\r\nimport \"fullpage.js/dist/jquery.fullpage.min.css\";\r\n\r\nimport FullpageSection from \"@components/Fullpage/fullpageSection\";\r\n\r\nconst Home = () => {\r\n  $(() => {\r\n    $(\"#fullpage\").fullpage({\r\n      menu: \"#menu\",\r\n      anchors: [\"1\", \"2\", \"3\"],\r\n      sectionsColor: [\"black\", \"black\", \"black\"], //이를 삭제하면 \"/\"에서만 섹션 이동이 가능하다.\r\n    });\r\n  });\r\n\r\n  return (\r\n    <Layout>\r\n      <div id=\"fullpage\">\r\n        <FullpageSection />\r\n      </div>\r\n    </Layout>\r\n  );\r\n};\r\n```\r\n\r\n+++\r\n\r\n## 3. 문제점\r\n\r\n다른 페이지는 문제가 없지만 fullpage.js를 적용한 페이지만 Header와 Footer를 묶어논 Layout에서 Footer가 보이지 않는 문제가 발생했다.\r\n\r\n### 3-1. 해결책\r\n\r\n1. 전역으로 설정한 Layout을 각각의 페이지마다 설정해준다.\r\n2. fullpage의 section을 추가해 footer를 추가로 section으로 넣어준다.\r\n\r\n```Typescript\r\n\r\nconst Home = () => {\r\n  $(() => {\r\n    $(\"#fullpage\").fullpage({\r\n      menu: \"#menu\",\r\n      anchors: [\"1\", \"2\", \"3\",\"footer\"],\r\n      sectionsColor: [\"black\", \"black\", \"black\",\"white],\r\n    });\r\n  });\r\n\r\n    return (\r\n    <>\r\n      <Header />\r\n      <div id=\"fullpage\">\r\n        {videos.map((video, index) => (\r\n          <div className=\"section\" id={`#section${index}`}>\r\n            <video\r\n              className=\"h-full w-full object-cover\"\r\n              data-autoplay\r\n              muted\r\n              loop\r\n            >\r\n              <source data-src={video} type=\"video/mp4\" />\r\n            </video>\r\n          </div>\r\n        ))}\r\n        <div className=\"section fp-auto-height\" id=\"#section4\">\r\n          <Footer />\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n```\r\n\r\nFullpageSection를 제거하고 Footer를 Section에 추가해주면 footer도 잘나오는 것을 확인 할 수 있다.\r\n"},{"excerpt":"1. PortOne 1-1. 간단한 연동성 포트원은 복잡한 PG결제 연동규격을 누구나 쉽게 연동할 수 있도록 결제창 연동은 JavaScript SDK 형태로 제공한다. 포트원을 사용하면 라이버르리 두 줄로 결제창 연동이 가능하다. 즉  구현이 가능하다는 큰 장점이 있다. 또한 거의 대부분의 결제 대행사를 한 번에 연동가능하다. 1-2. 다양한 언어 지원 …","fields":{"slug":"/PortOne사용하기/"},"frontmatter":{"date":"July 04, 2023","title":"Typescript & React PortOne으로 결제 테스트하기","tags":["ReactJS","TypeScript","PortOne","Blog","진경옥몰","결제모듈"]},"rawMarkdownBody":"\r\n## 1. PortOne\r\n\r\n### 1-1. 간단한 연동성\r\n\r\n- 포트원은 복잡한 PG결제 연동규격을 누구나 쉽게 연동할 수 있도록 결제창 연동은 JavaScript SDK 형태로 제공한다.\r\n- 포트원을 사용하면 라이버르리 두 줄로 결제창 연동이 가능하다.\r\n- 즉 `따로 모듈을 설치하지않아도` 구현이 가능하다는 큰 장점이 있다.\r\n- 또한 거의 대부분의 결제 대행사를 한 번에 연동가능하다.\r\n\r\n### 1-2. 다양한 언어 지원\r\n\r\n- `Java, Php, Python, Nodejs`등 다양한 언어를 지원한다.\r\n\r\n### 1-3. 결제 데이터를 모니터링해 보안에 강하다\r\n\r\n- 모든 결제 정보 암호화\r\n- 결제 정보 위/변조 시도 차단\r\n- 결제대행사 장애 사전 모니터링\r\n\r\n위 사항들을 지원해준다.\r\n\r\n## 2. 연동 준비하기\r\n\r\n우선 [공식문서](https://developers.portone.io/docs/ko/readme)에서 너무나 친절하게 설명되어 있다.\r\n\r\n### 2-1. PG 정보 설정\r\n\r\n- `결제 연동` => `테스트 연동관리`에서 본인의 `가맹점 식별코드`를 확인한다.(추후에 연동에서 사용해야하기 떄문)\r\n- 이때 `가맹점 식별코드`와 나머지 정보들은 정보가 노출되지 않게 보안을 철저히 한다. 결제 내역을 컨트롤할 수 있는 정보들이 담겨 있기 때문이다.\r\n\r\n### 2-2. 결제 대행사 테스트 설정하기\r\n\r\n- 사용하려는 대행사의 설정이 필요하다. 본 글에서는 가장 편하게 테스트를 하기위해서 카카오페이로 설정하여 진행하였다.\r\n\r\n![카카오페이 설정](1.png)\r\n\r\n### 2-3. 코드작성\r\n\r\n> Type에 맞게 interface를 설정하여 결제 type들을 정의해주어야한다.\r\n\r\n> [공식문서](https://github.com/iamport/iamport-react-example/blob/master/manuals/PAYMENT.md)에서 친절하게 코드도 작성되어있다. 테스트이기에 고객과 결제정보를 임의로 설정하고 진행한다.\r\n\r\n```Typescript\r\n//imp.d.ts\r\n\r\n\r\nexport interface RequestPayAdditionalParams {\r\n  digital?: boolean;\r\n  vbank_due?: string;\r\n  m_redirect_url?: string;\r\n  app_scheme?: string;\r\n  biz_num?: string;\r\n}\r\n\r\nexport interface Display {\r\n  card_quota?: number[];\r\n}\r\n\r\nexport interface RequestPayParams extends RequestPayAdditionalParams {\r\n  pg?: string;\r\n  pay_method: string;\r\n  escrow?: boolean;\r\n  merchant_uid: string;\r\n  name?: string;\r\n  amount: number;\r\n  custom_data?: any;\r\n  tax_free?: number;\r\n  currency?: string;\r\n  language?: string;\r\n  buyer_name?: string;\r\n  buyer_tel: string;\r\n  buyer_email?: string;\r\n  buyer_addr?: string;\r\n  buyer_postcode?: string;\r\n  notice_url?: string | string[];\r\n  display?: Display;\r\n}\r\n\r\nexport interface RequestPayAdditionalResponse {\r\n  apply_num?: string;\r\n  vbank_num?: string;\r\n  vbank_name?: string;\r\n  vbank_holder?: string | null;\r\n  vbank_date?: number;\r\n}\r\n\r\nexport interface RequestPayResponse extends RequestPayAdditionalResponse {\r\n  success: boolean;\r\n  error_code: string;\r\n  error_msg: string;\r\n  imp_uid: string | null;\r\n  merchant_uid: string;\r\n  pay_method?: string;\r\n  paid_amount?: number;\r\n  status?: string;\r\n  name?: string;\r\n  pg_provider?: string;\r\n  pg_tid?: string;\r\n  buyer_name?: string;\r\n  buyer_email?: string;\r\n  buyer_tel?: string;\r\n  buyer_addr?: string;\r\n  buyer_postcode?: string;\r\n  custom_data?: any;\r\n  paid_at?: number;\r\n  receipt_url?: string;\r\n}\r\n\r\nexport type RequestPayResponseCallback = (response: RequestPayResponse) => void;\r\n\r\nexport interface Iamport {\r\n  init: (accountID: string) => void;\r\n  request_pay: (\r\n    params: RequestPayParams,\r\n    callback?: RequestPayResponseCallback\r\n  ) => void;\r\n}\r\n\r\ndeclare global {\r\n  interface Window {\r\n    IMP?: Iamport;\r\n  }\r\n}\r\n```\r\n\r\n```TypeScript\r\n// payment.tsx\r\n\r\nimport { RequestPayParams, RequestPayResponse } from \"@hooks/imp\";\r\n\r\nfunction Payment() {\r\n  const onClickPayment = () => {\r\n    if (!window.IMP) return;\r\n    /* 1. 가맹점 식별하기 */\r\n    const { IMP } = window;\r\n    IMP.init(\"imp00000000\"); // 본인의 가맹점 식별코드를 적는다.\r\n\r\n    /* 2. 결제 데이터 정의하기 */\r\n    const data: RequestPayParams = {\r\n      pg: \"kakaopay\", // PG사의 종류를 선택한다. (https://portone.gitbook.io/docs/sdk/javascript-sdk/payrq#undefined-1)\r\n      pay_method: \"card\", // 결제수단\r\n      merchant_uid: `mid_${new Date().getTime()}`, // 주문번호\r\n      amount: 1000, // 결제금액\r\n      name: \"아임포트 결제 데이터 분석\", // 주문명\r\n      buyer_name: \"박명수\", // 구매자 이름\r\n      buyer_tel: \"01012345678\", // 구매자 전화번호\r\n      buyer_email: \"qwer1234@naver.com\", // 구매자 이메일\r\n      buyer_addr: \"가양동 42-11\", // 구매자 주소\r\n      buyer_postcode: \"32192\", // 구매자 우편번호\r\n      m_redirect_url: \"http://localhost:8080/orderCompleteMobile\",\r\n    };\r\n\r\n    /* 4. 결제 창 호출하기 */\r\n    IMP.request_pay(data, callback);\r\n  };\r\n\r\n  /* 3. 콜백 함수 정의하기 */\r\n  function callback(response: RequestPayResponse) {\r\n    const { success, error_msg } = response;\r\n\r\n    if (success) {\r\n      alert(\"결제 성공\");\r\n      console.log(response);\r\n    } else {\r\n      alert(`결제 실패: ${error_msg}`);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n        <button\r\n            onClick={onClickPayment}\r\n            className=\" my-20 border-2 border-black p-6 rounded-xl\"\r\n        >\r\n        결제하기\r\n        </button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Payment;\r\n```\r\n\r\n[참고블로그](https://velog.io/@gunilna/%ED%8F%AC%ED%8A%B8%EC%9B%90-Front-end-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0)\r\n"},{"excerpt":"1. Typescript로 세팅하기 1-1. Create React App(CRA)  으로 원하는 폴더에 typescript로 프로젝트를 할 기반 설정 및 설치를 한다.\nCRA로 설치 시 장점은 babel이나 webpack등을 기본적으로 설정해준다는 것이다.\n터미널은 윈도우기준 를 사용한다. 그러나 CRA는 Webpack 설정을 숨겨놓고 있기때문에, 수정…","fields":{"slug":"/Typescript로 초기세팅하기/"},"frontmatter":{"date":"June 27, 2023","title":"TypeScript로 진경옥몰 초기 세팅하기","tags":["ReactJS","TypeScript","Setting","Blog","진경옥몰"]},"rawMarkdownBody":"\r\n## 1. Typescript로 세팅하기\r\n\r\n### 1-1. Create React App(CRA)\r\n\r\n> `npx create-react-app 프로젝트명 --template typescript`\r\n\r\n으로 원하는 폴더에 typescript로 프로젝트를 할 기반 설정 및 설치를 한다.\r\nCRA로 설치 시 장점은 babel이나 webpack등을 기본적으로 설정해준다는 것이다.\r\n터미널은 윈도우기준 `git bash`를 사용한다.\r\n\r\n- 그러나 CRA는 Webpack 설정을 숨겨놓고 있기때문에, 수정하기 힘들다는 단점이 있다.\r\n\r\n## 2. TailwindCSS 설치하기\r\n\r\n- 이번 프로젝트는 CSS 프레임워크를 TailwindCSS로 정하여 세팅을 해주기로 했다. 왜냐면 일단 너무 간편하기도하고 평소에 주로 사용해봤기때문에...\r\n\r\n> `npm i -D tailwindcss postcss autoprefixer`\r\n\r\n### 2-1 tailwind.config.js 만들기\r\n\r\n> `npx tailwindcss init`명령어를 사용하여 tailwind.config.js 파일을 생성한다.\r\n\r\n```Javascript\r\nmodule.exports = {\r\n  content: [\"./src/**/*.{js,jsx,ts,tsx}\"],\r\n  theme: {\r\n    extend: {},\r\n  },\r\n  plugins: [],\r\n};\r\n```\r\n\r\ncontent안에 위와 같이 설정해준다(src폴더 사용경우)\r\n\r\n### 2-2 TailwindCSS 적용\r\n\r\nsrc/index.css 상단에\r\n\r\n```Css\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n```\r\n\r\n를 추가해준다.\r\n\r\n## 3. Redux 설치\r\n\r\n> ` npm i redux react-redux`\r\n>\r\n> `npm i --dev @types/react-redux `\r\n>\r\n> `npm i @reduxjs/toolkit`\r\n\r\n상태관리를 위해 Redux를 설치한다. 기본적인 구조는 [참고블로그](https://bum-developer.tistory.com/entry/React-Redux%EC%99%80-TypeScript-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)를 참고하여 구성하였다. 리덕스에 대한 설명은 다음번에 추가적으로 하도록 하겠다.\r\n\r\n## 4. Loadable 설치\r\n\r\n> `npm i @loadable/component`\r\n>\r\n> `npm i --save-dev @types/loadable/component`\r\n\r\n코드 스플리팅을 위해 설치한다. SPA의 단점인 초기 데이터 요청 시간이 길어짐을 보완할 수 있다.\r\n\r\n## 5. React-Router-DOM 설치하기\r\n\r\n> `npm i react-router-dom`\r\n>\r\n> `npm i react-router-dom @types/react-router-dom`\r\n>\r\n> `npm i --save @types/react @types/react-dom`\r\n\r\n### 5-1. 라우터 구성\r\n\r\n```Typescript\r\n./App.tsx\r\n\r\nimport React from \"react\";\r\nimport loadable from \"@loadable/component\";\r\nimport { Route, Routes } from \"react-router-dom\";\r\nconst Home = loadable(() => import(\"./pages/Home/index\"));\r\nconst LogIn = loadable(() => import(\"./pages/LogIn/index\"));\r\nconst SignUp = loadable(() => import(\"./pages/SignUp/index\"));\r\nconst Product = loadable(() => import(\"./pages/Product/index\"));\r\n\r\nfunction App() {\r\n  return (\r\n    <Routes>\r\n      <Route path=\"/\" element={<Home />} />\r\n      <Route path=\"/login\" element={<LogIn />} />\r\n      <Route path=\"/signup\" element={<SignUp />} />\r\n      <Route path=\"/product/:id\" element={<Product />} />\r\n    </Routes>\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\nloadable로 코드 스플리팅을 해주고 우선 필요할 것 같은 라우팅만 설정해준다.\r\n\r\n## 6. tsconfig paths를 절대경로로 설정하기\r\n\r\n원래는 tsconfig.json을\r\n\r\n```Json\r\n./tsconfig.json\r\n\r\n\"baseUrl\": \"./src\",\r\n\"paths\": {\r\n    \"@hooks/*\": [\"./hooks/*\"],\r\n    \"@components/*\": [\"./components/*\"],\r\n    \"@pages/*\": [\"./pages/*\"],\r\n    \"@utils/*\": [\"./utils/*\"],\r\n    \"@store/*\": [\"./store/*\"],\r\n    \"@reducer/*\": [\"./reducer/*\"]\r\n}\r\n```\r\n\r\n와 같이 수정하면 절대경로로 설정할 수 있다. 그러나 CRA로 구축했을때는 tsconfig.json에서 path를 인식하지 못하는 문제가 발생한다. CRA 내부의 Webpack 설정 때문에 tsconfig를 변경한 내용이 적용되지 않고 초기에 생성된 tsconfig 설정으로 돌아가기 때문이라고 한다.\r\n\r\n> `npm i @craco/craco`\r\n>\r\n> `npm i -D craco-alias`\r\n>\r\n> `npm i --save-dev react-app-alias`\r\n> 를 설치한 후 `루트 디렉토리`에 craco.config.js를 만든 후\r\n\r\n```JavaScript\r\n./craco.config.js\r\n\r\nconst { CracoAliasPlugin } = require('react-app-alias');\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n    {\r\n      plugin: CracoAliasPlugin,\r\n      options: {\r\n        source: 'tsconfig',\r\n        baseUrl: '.',\r\n        tsConfigPath: './tsconfig.paths.json',\r\n      },\r\n    },\r\n  ],\r\n};\r\n```\r\n\r\n와 같이 설정한다.<br/>\r\n그 후 덮어쓸 내용만 담은 tsconfig를 `tsconfig.paths.json`으로 따로 생성한 후\r\n\r\n```Json\r\n./tsconfig.paths.json\r\n\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \"./src\",\r\n    \"paths\": {\r\n      \"@components/*\": [\"./components/*\"],\r\n      \"@hooks/*\": [\"./hooks/*\"],\r\n      \"@pages/*\": [\"./pages/*\"],\r\n      \"@reducer/*\": [\"./reducer/*\"],\r\n      \"@store/*\": [\"./store/*\"],\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n와 같이 작성한다.<br/>\r\n(`tsconfig.paths.json`에 주석을 달면 에러가 발생한다.)<br/>\r\n`tsconfig`에는 extends 속성을\r\n\r\n```Json\r\n./tsconfig.json\r\n\r\n{\r\n  \"extends\": \"./tsconfig.paths.json\",\r\n  \"compilerOptions\": {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n와 같이 추가한 후 `package.json`에서 `react-scripts`명령어를 craco로 변경한다.\r\n\r\n```Json\r\n./package.json\r\n\r\n{\r\n  \"scripts\": {\r\n    \"start\": \"craco start\",\r\n    \"build\": \"craco build\",\r\n    \"test\": \"craco test\",\r\n    \"eject\": \"react-scripts eject\"\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 다음\r\n\r\n상품의 결제페이지를 만드는 방법을 정리하도록 하겠다.\r\n"},{"excerpt":"CRA로 TypeScript와 React, CSS로 TailwindCSS를 세팅해보자. 1. Create React App(CRA)  2. TailwindCSS 설치하기 \nor\n 으로 패키지를 개발 종속성으로 추가한다. 3. TailwindCSS config 파일 초기화  4. TailwindCSS 적용 src/index.css 상단에 를 추가해준다.","fields":{"slug":"/CRA로 Typescript 세팅하기/"},"frontmatter":{"date":"June 24, 2023","title":"TypeScript + TailwindCSS로 프로젝트 시작하기","tags":["ReactJS","TypeScript","CRA","TailwindCSS","Blog"]},"rawMarkdownBody":"\r\nCRA로 TypeScript와 React, CSS로 TailwindCSS를 세팅해보자.\r\n\r\n## 1. Create React App(CRA)\r\n\r\n> `npx create-react-app 프로젝트명 --template typescript`\r\n\r\n## 2. TailwindCSS 설치하기\r\n\r\n> `yarn add -D tailwindcss postcss autoprefixer`\r\n> or\r\n> `npm i -D tailwindcss postcss autoprefixer`\r\n\r\n- `D 옵션`으로 패키지를 개발 종속성으로 추가한다.\r\n\r\n## 3. TailwindCSS config 파일 초기화\r\n\r\n`yarn tailwind init -p`\r\n\r\n```Javascript\r\n./tailwind.config.js\r\n\r\nmodule.exports = {\r\n  content: [\r\n  \t\"./src/**/*.{js,jsx,ts,tsx}\",\r\n    // src 하위 파일 중 확장자가 .js,.jsx,.ts,.tsx인 파일을 대상으로 한다는 의미\r\n  ],\r\n  theme: {\r\n    extend: {},\r\n  },\r\n  plugins: [],\r\n}\r\n```\r\n\r\n## 4. TailwindCSS 적용\r\n\r\nsrc/index.css 상단에\r\n\r\n```Css\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n```\r\n\r\n를 추가해준다.\r\n"},{"excerpt":"CRA없이 TypeScript와 React를 세팅하는 방법이다. 1. package.json 생성 으로 package.json을 생성한다   2. Eslint eslint란 코드 점검 도구를 말한다. 직접 설정하면 팀원간 의견 충돌이 있으니 prettier에 위임한다.  를 생성한다. 3. Prettier  를 생성한후 를 넣어 기본세팅을 완료한다. 는 …","fields":{"slug":"/Typescript로 프로젝트 세팅하기/"},"frontmatter":{"date":"June 23, 2023","title":"TypeScript로 프로젝트 세팅하기","tags":["ReactJS","TypeScript","Setting","Blog"]},"rawMarkdownBody":"\r\nCRA없이 TypeScript와 React를 세팅하는 방법이다.\r\n\r\n## 1. package.json 생성\r\n\r\n- `npm init`으로 package.json을 생성한다\r\n- `npm i react react-dom`\r\n- `npm i typescript @types/react @types/react-dom`\r\n\r\n## 2. Eslint\r\n\r\n### eslint란\r\n\r\n- 코드 점검 도구를 말한다. 직접 설정하면 팀원간 의견 충돌이 있으니 prettier에 위임한다.\r\n- `npm i -D eslint`\r\n- `.eslintrc`를 생성한다.\r\n\r\n```json\r\n/.eslintrc\r\n{\r\n  \"extends\": [\"plugin:prettier/recommended\"]\r\n}\r\n```\r\n\r\n## 3. Prettier\r\n\r\n- `npm i -D prettier eslint-plugin-prettier eslint-config-prettier`\r\n- `.prettierrc`를 생성한후\r\n\r\n```json\r\n/.prettierrc\r\n{\r\n  \"printWidth\": 120,\r\n  \"tabWidth\": 2,\r\n  \"singleQuote\": true,\r\n  \"trailingComma\": \"all\",\r\n  \"semi\": true\r\n}\r\n```\r\n\r\n를 넣어 기본세팅을 완료한다.\r\n\r\n- `tabWidth`는 개행시 띄워지는 정도를 의미하고 `printWidth`는 한줄에 120이하까지만 적용시키겠다는 의미이다.\r\n\r\n## 4. TypeScript 설정\r\n\r\n- 언어 문법과 JavaScript 결과물이 어떻게 나와야하는지 설정하는 파일\r\n- TypeScript 설정파일인 tsconfig.json파일을 생성한\r\n\r\n```json\r\n./tsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"esModuleInterop\": true,\r\n    \"sourceMap\": true,\r\n    \"lib\": [\"ES2020\", \"DOM\"],\r\n    \"jsx\": \"react\",\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"Node\",\r\n    \"target\": \"es5\",\r\n    \"strict\": true, // true로 켜놓아야 타입을 체킹한다.\r\n    \"resolveJsonModule\": true,\r\n    \"baseUrl\": \".\",\r\n    \"paths\": {\r\n      \"@hooks/*\": [\"hooks/*\"],\r\n      \"@components/*\": [\"components/*\"],\r\n      \"@layouts/*\": [\"layouts/*\"],\r\n      \"@pages/*\": [\"pages/*\"],\r\n      \"@utils/*\": [\"utils/*\"],\r\n      \"@typings/*\": [\"typings/*\"]\r\n    }\r\n  },\r\n  \"ts-node\": {\r\n    \"compilerOptions\": {\r\n      \"module\": \"commonjs\",\r\n      \"moduleResolution\": \"Node\",\r\n      \"target\": \"es5\",\r\n      \"esModuleInterop\": true\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 5. Webpack 설정\r\n\r\n- ts, css, json, 최신 문법의 js파일들을 하나로 합쳐준다.\r\n- entry에서 파일을 선택하면 module에 정해진 rules대로 js로 변환하여 하나의 파일로 합쳐준다(output). plugins는 합치는 중 부가적인 효과를 준다.\r\n- ts는 babel-loader로, css는 style-loader와 css-loader를 통해 js로 변환한다.\r\n- babel에서는 @babel/preset-env(최신문법 전환) @babel/preset-react(리엑트 jsx 변환), @babel/preset-typescript(타입스크립트 변환)\r\n- publicPath가 /dist고 [name].js에서 [name]이 entry에 적힌대로 app으로 바뀌어 /dist/app.js가 결과물이 된다.\r\n- `npm i -D webpack @types/webpack @types/node`\r\n- `npm i -D css-loader style-loader @babel/core babel-loader @babel/preset-env @babel/preset-react @babel/preset-typescript`\r\n- `npm i style-loader css-loader`\r\n\r\n```Typescript\r\n./webpack.config.ts\r\n\r\nimport path from 'path';\r\nimport ReactRefreshWebpackPlugin from '@pmmmwh/react-refresh-webpack-plugin';\r\nimport webpack, { Configuration as WebpackConfiguration } from 'webpack';\r\nimport { Configuration as WebpackDevServerConfiguration } from 'webpack-dev-server';\r\n\r\ninterface Configuration extends WebpackConfiguration {\r\n  devServer?: WebpackDevServerConfiguration;\r\n}\r\n\r\nimport ForkTsCheckerWebpackPlugin from 'fork-ts-checker-webpack-plugin';\r\n\r\nconst isDevelopment = process.env.NODE_ENV !== 'production';\r\n\r\nconst config: Configuration = {\r\n  name: 'sleact',\r\n  mode: isDevelopment ? 'development' : 'production',\r\n  devtool: !isDevelopment ? 'hidden-source-map' : 'eval',\r\n  resolve: {\r\n    extensions: ['.js', '.jsx', '.ts', '.tsx', '.json'],\r\n    alias: {\r\n      '@hooks': path.resolve(__dirname, 'hooks'),\r\n      '@components': path.resolve(__dirname, 'components'),\r\n      '@layouts': path.resolve(__dirname, 'layouts'),\r\n      '@pages': path.resolve(__dirname, 'pages'),\r\n      '@utils': path.resolve(__dirname, 'utils'),\r\n      '@typings': path.resolve(__dirname, 'typings'),\r\n    },\r\n  },\r\n  entry: {\r\n    app: './client',\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.tsx?$/,\r\n        loader: 'babel-loader',\r\n        options: {\r\n          presets: [\r\n            [\r\n              '@babel/preset-env',\r\n              {\r\n                targets: { browsers: ['IE 10'] },\r\n                debug: isDevelopment,\r\n              },\r\n            ],\r\n            '@babel/preset-react',\r\n            '@babel/preset-typescript',\r\n          ],\r\n          env: {\r\n            development: {\r\n              plugins: [require.resolve('react-refresh/babel')],\r\n            },\r\n          },\r\n        },\r\n        exclude: path.join(__dirname, 'node_modules'),\r\n      },\r\n      {\r\n        test: /\\.css?$/,\r\n        use: ['style-loader', 'css-loader'],\r\n      },\r\n    ],\r\n  },\r\n  plugins: [\r\n    new ForkTsCheckerWebpackPlugin({\r\n      async: false,\r\n      // eslint: {\r\n      //   files: \"./src/**/*\",\r\n      // },\r\n    }),\r\n    new webpack.EnvironmentPlugin({ NODE_ENV: isDevelopment ? 'development' : 'production' }),\r\n  ],\r\n  output: {\r\n    path: path.join(__dirname, 'dist'),\r\n    filename: '[name].js',\r\n    publicPath: '/dist/',\r\n  },\r\n  devServer: {\r\n    historyApiFallback: true, // react router\r\n    port: 3090,\r\n    devMiddleware: { publicPath: '/dist/' },\r\n    static: { directory: path.resolve(__dirname) },\r\n    proxy: {\r\n      '/api/': {\r\n        target: 'http://localhost:8080', //post보낼 api주소를 작성한다.\r\n        changeOrigin: true,\r\n      },\r\n    }, //proxy를 api주소로 설정해준다.\r\n  },\r\n};\r\n\r\nif (isDevelopment && config.plugins) {\r\n  config.plugins.push(new webpack.HotModuleReplacementPlugin());\r\n  config.plugins.push(new ReactRefreshWebpackPlugin());\r\n}\r\nif (!isDevelopment && config.plugins) {\r\n}\r\n\r\nexport default config;\r\n```\r\n\r\n## 6. index.html 작성\r\n\r\n```Html\r\n./index.html\r\n\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\"\r\n          content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\r\n    <title>타이틀</title>\r\n    <style>\r\n      html, body {\r\n          margin: 0;\r\n          padding: 0;\r\n          overflow: initial !important;\r\n      }\r\n      body {\r\n          font-size: 15px;\r\n          line-height: 1.46668;\r\n          font-weight: 400;\r\n          font-variant-ligatures: common-ligatures;\r\n          -moz-osx-font-smoothing: grayscale;\r\n          -webkit-font-smoothing: antialiased;\r\n      }\r\n      * {\r\n          box-sizing: border-box;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"app\"></div>\r\n    <script src=\"/dist/app.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n```Typescript\r\n./Client.tsx\r\n\r\nimport 'core-js/stable';\r\nimport 'regenerator-runtime/runtime';\r\nimport React from 'react';\r\nimport { render } from 'react-dom';\r\nimport { BrowserRouter } from 'react-router-dom';\r\nimport App from '@layouts/App';\r\n\r\nrender(\r\n  <BrowserRouter>\r\n    <App />\r\n  </BrowserRouter>,\r\n  document.querySelector('#app'),\r\n);\r\n```\r\n\r\n## 7. tsconfig-for-webpack-config.json\r\n\r\n- `npm i cross-env`\r\n- webpack할 때 webpack.config.ts를 인식 못하는 문제\r\n- package.json의 scripts의 build를 cross-env TS_NODE_PROJECT=\\\"tsconfig-for-webpack-config.json\\\" webpack\r\n\r\n```Json\r\n./package.json\r\n\r\n\"scripts\": {\r\n    \"dev\": \"webpack serve --env development\",\r\n    \"build\": \"cross-env NODE_ENV=production webpack\"\r\n  },\r\n```\r\n\r\n- `npm run build`\r\n- index.html 실행해보기\r\n\r\n```Json\r\n./tsconfig-for-webpack-config.json\r\n\r\n{\r\n  \"compilerOptions\": {\r\n    \"module\": \"commonjs\",\r\n    \"moduleResolution\": \"Node\",\r\n    \"target\": \"es5\",\r\n    \"esModuleInterop\": true\r\n  }\r\n}\r\n```\r\n\r\n## 8. Webpack Dev 서버 설치\r\n\r\n- 개발용 서버인 devServer 옵션 추가(port는 3090, publicPath는 /dist/로)\r\n- webpack serve할 때 webpack.config.ts를 인식 못하는 문제\r\n- `npm i -D ts-node webpack-dev-server @types/webpack-dev-server webpack-cli`\r\n- package.json의 scripts의 dev를 cross-env TS_NODE_PROJECT=\\\"tsconfig-for-webpack-config.json\\\" webpack serve --env development\r\n\r\n```Json\r\n./package.json\r\n\r\n\"scripts\": {\r\n    \"dev\": \"webpack serve --env development\",\r\n    \"build\": \"cross-env NODE_ENV=production webpack\"\r\n  },\r\n```\r\n\r\n- npm run dev하면 localhost:3090에서 서버 실행됨.\r\n\r\n## 9. Hot reloading 설정\r\n\r\n- 새로고침 하면 자동으로 업데이트 되는 기능\r\n- CRA에서는 자동으로 내장되어있지만, 원래는 일일이 설정해줘야하는 기능이다.\r\n- `npm i -D @pmmmwh/react-refresh-webpack-plugin react-refresh`\r\n- webpack의 babel-loader 안에 설정(env) 및 plugin으로 추가\r\n\r\n```Typescript\r\n./webpack.config.ts\r\n\r\n...\r\n...\r\n...\r\n\r\nmodule: {\r\n    rules: [\r\n      {\r\n        test: /\\.tsx?$/,\r\n        loader: 'babel-loader',\r\n        options: {\r\n          presets: [\r\n            [\r\n              '@babel/preset-env',\r\n              {\r\n                targets: { browsers: ['IE 10'] },\r\n                debug: isDevelopment,\r\n              },\r\n            ],\r\n            '@babel/preset-react',\r\n            '@babel/preset-typescript',\r\n          ],\r\n          env: {\r\n            development: {\r\n              plugins: [require.resolve('react-refresh/babel')],\r\n            },\r\n          },\r\n        },\r\n        exclude: path.join(__dirname, 'node_modules'),\r\n      },\r\n      {\r\n        test: /\\.css?$/,\r\n        use: ['style-loader', 'css-loader'],\r\n      },\r\n    ],\r\n  },\r\n...\r\n...\r\n...\r\n```\r\n\r\n## 10. fork-ts-checker-webpack-plugin\r\n\r\n- webpack은 ts체크 후 eslint체크 후 빌드 시작\r\n- ts랑 eslint는 동시에 체크하면 더 효율적이다.\r\n- 이 플러그인이 동시에 진행하게 해준다.\r\n\r\n```Typescript\r\n./webpack.config.ts\r\n\r\nimport ForkTsCheckerWebpackPlugin from 'fork-ts-checker-webpack-plugin';\r\n...\r\n...\r\n...\r\nplugins: [\r\n    new ForkTsCheckerWebpackPlugin({\r\n      async: false,\r\n      // eslint: {\r\n      //   files: \"./src/**/*\",\r\n      // },\r\n    }),\r\n    new webpack.EnvironmentPlugin({ NODE_ENV: isDevelopment ? 'development' : 'production' }),\r\n  ],\r\n...\r\n...\r\n...\r\n```\r\n\r\n## 11. 폴더 구조는 취향대로 세팅한다.\r\n\r\n- pages\r\n- components\r\n- hooks\r\n- utils\r\n\r\n크게 위와같이 구분할 수 있다. 폴더 이름과 구조는 개개인마다 다르니 그때마다 새로운 시도를 해보자.\r\n\r\n## 12. ts와 webpack에서 alias 지정\r\n\r\n- `npm i -D tsconfig-paths`\r\n- tsconfig에서 baseUrl와 paths 설정\r\n- webpack에서는 resolve안에 alias 설정\r\n\r\n```json\r\n./tsconfig.json\r\n\r\n...\r\n...\r\n...\r\n\r\n\"paths\": {\r\n      \"@hooks/*\": [\"hooks/*\"],\r\n      \"@components/*\": [\"components/*\"],\r\n      \"@layouts/*\": [\"layouts/*\"],\r\n      \"@pages/*\": [\"pages/*\"],\r\n      \"@utils/*\": [\"utils/*\"],\r\n      \"@typings/*\": [\"typings/*\"]\r\n    }\r\n...\r\n...\r\n...\r\n```\r\n\r\n와 같이 설정할 수 있고, src폴더안에 페이지 구조를 담는다면 src를 앞에 추가해준다.\r\n\r\n## 13. 부가적인 기능들 세팅\r\n\r\nRouterDom\r\n\r\n- `npm i react-router react-router-dom`\r\n- `npm i -D @types/react-router @types/react-router-dom`\r\n- `npm i axios`\r\n\r\n- CSS는 취향대로 사용한다.\r\n  - 개인적으로 나는 TailwindCSS, Styled-Component를 주로 사용한다.\r\n  - TailwindCSS를 적용시키는 방법은 추후에 다시 설명하도록 하겠다.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}